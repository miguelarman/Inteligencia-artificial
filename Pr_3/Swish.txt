igual(X,X).

% Ejercicio 2
concatena([],L,L).
concatena([X|L],L1,[X|L2]) :- concatena(L,L1,L2).

invierte([],[]) :- !.
invierte([F|R],L) :- concatena(I, [F], L), invierte(R, I).

% Ejercicio 3
palindromo(X) :- invierte(Y, X), igual(X,Y).

% Ejercicio 4
divide(L,0,L1,L2) :- igual(L1,[]), igual(L,L2).
divide([A|L],N,[B|L1],L2) :- igual(A,B),N>0,succ(New, N),divide(L,New,L1,L2).

% Ejercicio 5
aplasta([], []) :- !.
aplasta([X], [X]) :- not(is_list(X)), !.
aplasta([X], Y) :- is_list(X), aplasta(X,Y), !.
aplasta([X|L], R) :- aplasta([X], LX), aplasta(L, LL), concatena(LX, LL, R).

% Ejercicio 6
% Caso base
primos(1, []) :- !.
% Se llama a la funcion recursiva pri_apartir
primos(N, L) :- N>1, pri_apartir(N,2,L), !.

% pri_apartir calcula los factores primos de N a partir de I
% Caso base: solo queda un factor, por lo que N y I son iguales
pri_apartir(N,I,[Last]) :- 
    next_factor(N,I,Next), New is N/Next, igual(New,1), igual(Last,Next), !.
% Caso general: la lista de factores es el primer factor mas los factores
% que dan lugar de la division de N/Next
pri_apartir(N,I,[Next|L]) :- 
    next_factor(N,I,Next), New is N/Next, pri_apartir(New,Next,L), !.

% Permite saber si un numero divide a otro
divide(D, N) :- N>0, D>0, 0 is mod(N, D).

% Funcion recursiva que mira si todos los numeros por debajo de N
% son coprimos con él
% Caso base: si se ha llegado a 1, se devuelve True
es_primo(N, 1) :- N>0, !.
% Caso general: se mira si no divide a cierto número, y recursivamente
% si no divide a todos los inferiores
es_primo(N, Num) :-
    N>0, Num>0, not(divide(Num, N)), New is Num-1, es_primo(N, New).
% Calcula si un numero es primo
primo(N) :- N>0, es_primo(N, N-1).

% Calcula el siguiente factor (el mismo si esta repetido) de un numero
% N, donde F es el factor inicial y NF el siguiente
% Caso base: si F divide al numero, F es el siguiente factor
next_factor(N, F, NF) :- divide(F, N), igual(F,NF), !.
% Si F es 2, el siguiente factor a comprobar es 3
next_factor(N, 2, NF) :- next_factor(N, 3, NF).
% Si F es cualquier otro factor que se este comprobando, el siguiente
% factor a mirar es F+2.
next_factor(N, F, NF) :- N>=F, New is F+2, next_factor(N, New, NF).

% Ejercicio 8

% Devuelve la dupla de mayor peso
% Caso base: si hay un elemento, el elemento de mayor peso es el
% unico posible
mayor_peso(L-P,[L-P|[]]).
% Caso general 1: si el primer elemento es mayor que el mayor elemento
% del resto, el primer elemento es el mayor de la lista
mayor_peso(L-P,[L-P|LL]) :- mayor_peso(_-New, LL), P>=New.
% Caso general 2: si el primer elemento no es mayor, conservamos
% el mayor elemento
mayor_peso(NNew-New,[_-P|LL]) :- mayor_peso(NNew-New, LL), P<New.

% Elimina una dupla de la lista conociendo el primer elemento
% Caso base: se elimina el primer elemento, que es el que queriamos
elimina_elem(E, [E-_|L], L).
% Caso general: se concatena el primer elemento con el resto de la
% lista, que contiene el elemento eliminado.
elimina_elem(E, [L-P|LL], [L-P|New]) :- elimina_elem(E, LL, New).


% Caso base: si hay un elemento, las dos hojas son  nil
build_tree([ER-_|[]], Tree) :- igual(Tree,tree(ER, nil, nil)).
% Caso general: el primer elemento conforma la rama izquierda y el
% resto la derecha
build_tree([ER-PR|L],Tree) :- 
	build_tree(L, NewR), build_tree([ER-PR],NewL), 
    igual(Tree, tree(1,NewL,NewR)).

% Funciones auxiliares para encontrar la info o una hoja del arbol
info(tree(I,_,_),I).
left(tree(_,L,_),L).
right(tree(_,_,R),R).

% Casos base: una de las hojas contiene el nodo que buscabamos
encode_elem(X1,X2,Tree):- 
    left(Tree, L), info(L, IL), igual(IL,X1), igual(X2,[0]).
encode_elem(X1,X2,Tree):-
    right(Tree, R), info(R, IR), igual(IR,X1), igual(X2,[1]).
% Caso general: se añade un 1 a la codificacion y se concatena con
% el resultado que de la busqueda en la hoja derecha
encode_elem(X1,X2,Tree):-
    right(Tree,RTree),encode_elem(X1,New,RTree),concatena([1],New,X2).

% Caso base: solo hay un elemento que codificar
encode_list([L1|[]], [L2], Tree):- encode_elem(L1,L2,Tree).
% Caso general: se codifica el primer elemento y se concatena 
% recursivamente con el resto
encode_list([L|R],L2,Tree):- 
    encode_elem(L,NewE,Tree), encode_list(R,NewL,Tree), 
    concatena([NewE],NewL,L2). 